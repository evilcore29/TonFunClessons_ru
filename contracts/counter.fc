#include "imports/stdlib.fc";

;; ЗАДАЧА
;; Смарт-контракт, который мы будем делать, должен обладать следующей функциональностью:
;; Хранить в своих данных целое число total - 64-битное число без знака
;; При получении внутреннего входящего сообщения контракт должен взять 32-битное целое число без знака из тела сообщения, добавить его к total и сохранить в своих данных
;; В смарт-контракте должен быть предусмотрен метод get_total позволяющий вернуть значение total
;; Если тело входящего сообщения меньше 32 бит, то контракт должен выдать исключение

;; числа с балансом
;; сумма сообщения
;; ячейка с исходным сообщением
;; слайс с телом принимаемого сообщения
;; impure - модификатор для функции который указывает компилятору что функцию нельзя удалять при оптимизациях кода
;; cell - ячейка данных в TVM
;; slice - кусок ячейки из cell, используется для прочтения данных из cell
;; builder - конструктор ячейки данных в TVM, который можно далее преобразовать в cell

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
  ;; исключения можно бросить используя операторы throw_if, throw_unless, throw
  ;; выбрасыватеся ошибка с кодом 35 если in_msg_body меньше 32 бит
  ;; коды ошибок https://docs.ton.org/learn/tvm-instructions/tvm-exit-codes
  throw_if(35, in_msg_body.slice_bits() < 32);


  ;; читаем данные из слайса in_msg_body
  ;; load_uint - функция для прочтения целого числа из слайса из стандартной библиотеки FunC
  int n = in_msg_body~load_uint(32);

  ;; для хранения постоянных данных у TVM есть отдельный регистр c4 с типом Cell
  ;; get_data - достает данные из c4
  ;; begin_parse - преобразует ячейку c4 в слайс
  slice ds = get_data().begin_parse();
  ;; читаем из ds целое число которое хранится в c4
  int total = ds~load_uint(64);

  ;; суммируем то что пришло в сообщении с тем что записано в c4
  total += n;

  ;; Для того, чтобы сохранить значение total в постоянные данные контракта, нам необходимо выполнить четыре действия:
  ;; Создать Builder для будущей ячейки данных
  ;; Записать в этот билдер значение
  ;; Преобразовать билдер в ячейку
  ;; Записать полученную ячейку в регистр c4

  ;; begin_cell - соаздет builder
  ;; store_uint - запишет total в builder
  ;; end_cell - преобразует builder в ячейку
  ;; set_data - записывает ячейку в регистр c4
  set_data(begin_cell().store_uint(total, 64).end_cell());
}


;; Любая функция в FunC соответствует следующему паттерну:
;; [<forall declarator>] <return_type><function_name(<comma_separated_function_args>) <specifiers>
;; Спецификация method_id позволяет вызывать функцию по её названию. Для гет-методов это обязательно.

int get_total() method_id {
  slice ds = get_data().begin_parse();
  int total = ds~load_uint(64);

  return total;
}

